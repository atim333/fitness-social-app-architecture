# 11. Архитектурные решения (ADR - Architectural Decision Records)

## Обзор
Architectural Decision Records (ADR) документируют ключевые архитектурные решения, принятые в проекте, их контекст, последствия и статус.

## Формат ADR
Каждое ADR следует шаблону:
- **Title:** Идентификатор и краткое описание решения
- **Status:** Предложено/Принято/Устарело
- **Context:** Проблема или возможность, требующая решения
- **Decision:** Принятое решение
- **Consequences:** Последствия (положительные и отрицательные)
- **Alternatives Considered:** Рассмотренные альтернативы
- **Related Decisions:** Связанные решения

---

## ADR-001: Выбор микросервисной архитектуры с постепенной миграцией

### Статус
Принято (2024-01-15)

### Контекст
Необходимо разработать фитнес-социальное приложение, которое должно:
- Масштабироваться до миллионов пользователей по всему миру
- Поддерживать независимые циклы разработки для разных функциональных блоков
- Интегрироваться с разнородными внешними системами
- Обслуживать пользователей в регионах с разной инфраструктурой

### Решение
Принять гибридный подход: начать с четко модулизированного монолита (модульный монолит) для MVP, с планом постепенного выделения сервисов в микросервисы по мере роста нагрузки и команды.

### Последствия
**Положительные:**
- Ускорение выхода MVP (меньше накладных расходов на инфраструктуру)
- Упрощенная отладка и тестирование на начальных этапах
- Возможность пересмотреть границы сервисов после получения обратной связи
- Меньшие требования к квалификации команды на старте

**Отрицательные:**
- Необходимость планирования миграции с самого начала
- Дополнительные усилия на рефакторинг при выделении сервисов
- Временное ограничение в независимом масштабировании компонентов

### Рассмотренные альтернативы
1. **Чистый монолит:** Отклонен из-за проблем с масштабированием и независимостью развертывания.
2. **Полные микросервисы с первого дня:** Отклонен из-за высокой сложности и накладных расходов для MVP.
3. **Serverless-архитектура:** Рассмотрен, но отклонен из-за требований к stateful-операциям и потенциальным проблемам с холодным стартом.

### Связанные решения
- ADR-002 (Выбор событийной шины)
- ADR-003 (Стратегия хранения данных)
- ADR-007 (Стратегия развертывания)

---

## ADR-002: Использование Apache Kafka в качестве событийной шины

### Статус
Принято (2024-01-15)

### Контекст
Требуется обеспечить асинхронную коммуникацию между сервисами для:
- Обработки социальных событий (лайки, комментарии, уведомления)
- Синхронизации данных между сервисами в eventual consistency модели
- Обеспечения отказоустойчивости при временной недоступности сервисов
- Поддержки обработки потока данных с фитнес-устройств

### Решение
Использовать Apache Kafka в качестве основной событийной шины для асинхронной коммуникации между сервисами.

### Последствия
**Положительные:**
- Высокая пропускная способность (миллионы сообщений в секунду)
- Гарантированная доставка сообщений
- Поддержка реигрывания событий (replay)
- Широкие возможности масштабирования (партиции, репликация)
- Интеграция с экосистемой обработки данных (Kafka Streams, Connect)

**Отрицательные:**
- Сложность настройки и эксплуатации кластера Kafka
- Дополнительная инфраструктурная компонента для поддержки
- Кривая обучения для команды
- Необходимость управления схемами сообщений (Schema Registry)

### Рассмотренные альтернативы
1. **RabbitMQ:** Отклонен из-за меньшей производительности при больших объемах данных.
2. **AWS SNS/SQS:** Рассмотрен для облачных развертываний, но отклонен из-за vendor lock-in и требований к мультиоблачности.
3. **NATS:** Рассмотрен, но отклонен из-за менее развитой экосистемы и меньшей гарантии доставки.

### Связанные решения
- ADR-004 (Формат сериализации сообщений)
- ADR-008 (Стратегия обработки ошибок)

---
## ADR-003: Полиглотная стратегия хранения данных

### Статус
Принято (2024-01-16)

### Контекст
Различные типы данных в приложении имеют разные требования:
- **Профили пользователей:** Транзакционность, сложные запросы
- **Социальный граф:** Графовые операции, поиск связей
- **Тренировки и телеметрия:** Запись временных рядов, большие объемы
- **Кэш и сессии:** Низкая задержка, высокая доступность
- **Поиск и агрегации:** Полнотекстовый поиск, сложные агрегации

### Решение
Использовать полиглотное хранение данных с выбором оптимальной базы данных для каждого типа данных:
1. **PostgreSQL** для транзакционных данных (пользователи, заказы)
2. **MongoDB** для данных тренировок (гибкая схема, геопространственные индексы)
3. **Redis** для кэша, сессий и лидербордов
4. **TimescaleDB** для временных рядов (медицинские данные)
5. **Cassandra** для масштабируемой аналитики
6. **Elasticsearch** для поиска и аналитики

### Последствия
**Положительные:**
- Оптимальная производительность для каждого типа операций
- Возможность независимого масштабирования хранилищ
- Использование сильных сторон каждой технологии

**Отрицательные:**
- Сложность управления несколькими системами
- Необходимость синхронизации данных между разными хранилищами
- Повышенные требования к экспертизе команды
- Усложнение резервного копирования и восстановления

### Рассмотренные альтернативы
1. **Единая SQL база:** Отклонен из-за проблем с масштабированием и разнородностью данных.
2. **Единая NoSQL база:** Отклонен из-за недостаточной транзакционности и сложности графовых операций.
3. **Новый SQL (CockroachDB, TiDB):** Рассмотрен, но отклонен из-за недостаточной зрелости для графовых операций.

### Связанные решения
- ADR-005 (Стратегия репликации и шардирования)
- ADR-009 (Стратегия резервного копирования)
- ADR-015 (Идемпотентность критических операций)

---

## ADR-004: Использование Protocol Buffers для сериализации сообщений

### Статус
Принято (2024-01-16)

### Контекст
Требуется эффективный формат сериализации для:
- Межсервисной коммуникации (gRPC)
- Сообщений в Apache Kafka
- Долгосрочного хранения событий в логе

### Решение
Использовать Protocol Buffers (protobuf) в качестве основного формата сериализации для всех межсервисных коммуникаций и сообщений в Kafka.

### Последствия
**Положительные:**
- Высокая производительность (меньший размер сообщений, быстрая сериализация)
- Строгая типизация и схема сообщений
- Поддержка версионирования схем
- Широкая поддержка в различных языках программирования
- Интеграция с gRPC

**Отрицательные:**
- Необходимость поддержки файлов .proto в репозитории
- Дополнительный шаг компиляции при сборке
- Менее человекочитаемый формат по сравнению с JSON

### Рассмотренные альтернативы
1. **JSON:** Отклонен из-за большего размера сообщений и отсутствия строгой схемы.
2. **Avro:** Рассмотрен, но отклонен из-за меньшей производительности и более слабой поддержки в некоторых языках.
3. **XML:** Отклонен из-за большого размера и сложности парсинга.

### Связанные решения
- ADR-002 (Использование Apache Kafka)
- ADR-010 (Стратегия API Gateway)

---
## ADR-005: Геошардирование данных по регионам

### Статус
Принято (2024-01-17)

### Контекст
Приложение должно обслуживать пользователей по всему миру с минимальной задержкой. Пользовательские данные должны быть доступны быстро, независимо от местоположения пользователя.

### Решение
Реализовать геошардирование данных, где данные пользователей хранятся в регионе, ближайшем к их основному местоположению.

### Последствия
**Положительные:**
- Низкая задержка доступа к данным для пользователей
- Соответствие требованиям GDPR и другим регуляторным нормам
- Уменьшение трансграничного трафика данных
- Возможность независимого масштабирования по регионам

**Отрицательные:**
- Сложность кросс-региональных запросов (друзья в разных регионах)
- Усложнение миграции пользователей между регионами
- Необходимость репликации глобальных данных (каталог товаров, промоакции)
- Усложнение аналитики по всем регионам

### Рассмотренные альтернативы
1. **Единый глобальный кластер:** Отклонен из-за высокой задержки для удаленных регионов.
2. **Полная репликация во все регионы:** Отклонен из-за высоких затрат на хранение и сложности поддержания согласованности.
3. **Кэширование в регионах с мастером в одном:** Рассмотрен, но отклонен из-за требований GDPR к хранению данных в регионе.

### Связанные решения
- ADR-003 (Полиглотная стратегия хранения)
- ADR-011 (Стратегия репликации между регионами)

---

## ADR-006: Использование Kubernetes для оркестрации контейнеров

### Статус
Принято (2024-01-17)

### Контекст
Требуется платформа для оркестрации контейнеров, которая:
- Поддерживает мультиоблачное развертывание
- Обеспечивает автоматическое масштабирование
- Упрощает развертывание и управление микросервисами
- Поддерживает различные стратегии развертывания (canary, blue-green)

### Решение
Использовать Kubernetes в качестве основной платформы для оркестрации контейнеров во всех окружениях (dev, staging, production).

### Последствия
**Положительные:**
- Единая платформа для всех окружений
- Поддержка мультиоблачных развертываний
- Богатая экосистема инструментов и расширений
- Автоматическое масштабирование (HPA, VPA)
- Встроенные механизмы отказоустойчивости (health checks, readiness probes)

**Отрицательные:**
- Высокая сложность настройки и эксплуатации
- Требует значительных экспертных знаний
- Накладные расходы на управление кластером
- Сложность миграции существующих приложений

### Рассмотренные альтернативы
1. **Docker Swarm:** Отклонен из-за меньшей функциональности и экосистемы.
2. **AWS ECS/Fargate:** Рассмотрен для AWS, но отклонен из-за vendor lock-in и требований к мультиоблачности.
3. **Nomad:** Рассмотрен, но отклонен из-за меньшей распространенности и экосистемы.

### Связанные решения
- ADR-007 (Стратегия развертывания)
- ADR-012 (Стратегия мониторинга)

---
## ADR-007: Мультиоблачная стратегия развертывания

### Статус
Принято (2024-01-18)

### Контекст
Компания использует несколько облачных провайдеров (90% систем в облаке, нет единого провайдера). Требуется стратегия, которая:
- Избегает vendor lock-in
- Обеспечивает лучшую производительность в разных регионах
- Использует существующие скидки и соглашения компании

### Решение
Принять мультиоблачную стратегию с доминированием AWS, но с поддержкой других провайдеров (GCP, Azure) для специфических регионов или сервисов:
- **AWS (60%):** Основные регионы (EU-West, US-East) - Identity, Social, Workout, Commerce
- **Google Cloud (25%):** AP-Southeast - Analytics, ML рекомендации, BigQuery
- **Azure (15%):** Корпоративные интеграции, Health (HIPAA compliance), Active Directory

### Последствия
**Положительные:**
- Избежание зависимости от одного провайдера
- Использование лучших сервисов каждого провайдера
- Улучшение переговорной позиции с провайдерами
- Повышенная отказоустойчивость (провайдер как единая точка отказа)

**Отрицательные:**
- Высокая сложность управления
- Необходимость экспертизы в нескольких платформах
- Потенциально более высокие общие затраты
- Сложности с передачей данных между облаками

### Рассмотренные альтернативы
1. **Единый облачный провайдер (AWS):** Отклонен из-за риска vendor lock-in и возможных ограничений в некоторых регионах.
2. **Гибридное облако (on-premise + cloud):** Отклонен из-за высоких капитальных затрат и сложности масштабирования.
3. **Выбор провайдера по региону:** Рассмотрен, но принят как часть решения (GCP для Азии, AWS для остального мира).

### Связанные решения
- ADR-005 (Геошардирование данных)
- ADR-006 (Использование Kubernetes)

---

## ADR-008: Circuit Breaker для взаимодействия с внешними сервисами

### Статус
Принято (2024-01-18)

### Контекст
Приложение зависит от множества внешних сервисов (платежные системы, фитнес-устройства, картографические сервисы). Сбои во внешних сервисах не должны приводить к каскадным отказам в приложении.

### Решение
Реализовать паттерн Circuit Breaker для всех взаимодействий с внешними сервисами.

### Последствия
**Положительные:**
- Предотвращение каскадных отказов
- Улучшенная отказоустойчивость системы
- Быстрое обнаружение проблем во внешних сервисах
- Возможность graceful degradation функциональности

**Отрицательные:**
- Усложнение кода клиентов внешних сервисов
- Необходимость настройки параметров для каждого сервиса
- Риск ложных срабатываний

### Рассмотренные альтернативы
1. **Retry с экспоненциальной отсрочкой:** Рассмотрен как дополнение к Circuit Breaker, но не как замена.
2. **Bulkhead:** Рассмотрен для изоляции ресурсов, принят как дополнительная мера.
3. **Таймауты:** Рассмотрены как базовая мера, но недостаточные для полной защиты.

### Связанные решения
- ADR-002 (Использование Apache Kafka для асинхронной обработки)

---
## ADR-009: Использование OpenTelemetry для распределенного трейсинга

### Статус
Принято (2024-01-19)

### Контекст
В микросервисной архитектуре сложно отслеживать выполнение запросов, проходящих через несколько сервисов. Требуется решение для:
- Трассировки запросов через всю систему
- Измерения производительности отдельных компонентов
- Анализа зависимостей между сервисами

### Решение
Использовать OpenTelemetry в качестве стандарта для сбора телеметрии (трейсы, метрики, логи) во всех сервисах.

### Последствия
**Положительные:**
- Единый стандарт для всей телеметрии
- Поддержка множества бэкендов (Jaeger, Zipkin, Prometheus)
- Автоматическая инструментация для многих библиотек
- Активно развивающееся сообщество и стандарт

**Отрицательные:**
- Относительная новизна стандарта (некоторая нестабильность API)
- Необходимость инструментации всех сервисов
- Дополнительные накладные расходы на сбор и хранение данных

### Рассмотренные альтернативы
1. **Jaeger/Zipkin напрямую:** Отклонен из-за отсутствия единого стандарта и поддержки метрик.
2. **Проприетарные решения (Datadog, New Relic):** Рассмотрены, но отклонены из-за высокой стоимости и vendor lock-in.
3. **Собственное решение:** Отклонен из-за высоких затрат на разработку и поддержку.

### Связанные решения
- ADR-012 (Стратегия мониторинга)

---

## ADR-010: GraphQL для внешнего API

### Статус
Принято (2024-01-19)

### Контекст
Клиентские приложения (iOS, Android, Web) имеют разные требования к данным. Мобильным клиентам особенно важно минимизировать объем передаваемых данных и количество запросов.

### Решение
Использовать GraphQL в качестве основного протокола для внешнего API (клиент-серверное взаимодействие).

### Последствия
**Положительные:**
- Клиенты запрашивают только нужные данные (минимизация передачи)
- Единая конечная точка для всех запросов
- Строгая типизация API
- Возможность агрегации данных из нескольких сервисов на уровне API Gateway
- Автоматическая документация через introspection

**Отрицательные:**
- Сложность кэширования (по сравнению с REST)
- Потенциальные проблемы с производительностью при сложных запросах (N+1)
- Сложность валидации и авторизации на уровне полей
- Дополнительная нагрузка на сервер для парсинга и валидации запросов

### Рассмотренные альтернативы
1. **REST:** Отклонен из-за over-fetching и under-fetching данных, а также необходимости поддерживать множество endpoint'ов.
2. **gRPC:** Рассмотрен для мобильных клиентов, но отклонен из-за сложности работы в браузерах и менее гибкого формата запросов.
3. **REST + спецификация (OpenAPI):** Рассмотрен, но отклонен в пользу более гибкого GraphQL.

### Связанные решения
- ADR-004 (Protocol Buffers для внутренней коммуникации)

---

## ADR-011: Применение Domain-Driven Design (DDD) для моделирования бизнес-логики

### Статус
Принято (2024-01-20)

### Контекст
Требуется смоделировать сложную бизнес-логику фитнес-социального приложения с четким разделением ответственности. Приложение включает:
- Социальные взаимодействия (друзья, группы, сообщества)
- Тренировочные процессы и метрики
- Интеграцию медицинских устройств
- Систему рекомендаций и коммерции

### Решение
Применить подход Domain-Driven Design (DDD) с выделением ограниченных контекстов:
1. **Core Domain:** User & Social Context (смысловое ядро)
2. **Supporting Domains:** Activity & Training, Health & Devices, Commerce & Recommendations
3. **Generic Domains:** Геймификация, Уведомления, Аналитика

### Последствия
**Положительные:**
- Архитектура точно отражает бизнес-процессы
- Единый язык между разработчиками и бизнесом
- Четкие границы ответственности для каждой команды
- Возможность независимой эволюции доменов
- Упрощение тестирования бизнес-логики

**Отрицательные:**
- Кривая обучения для команды
- Начальные затраты на проектирование доменной модели
- Сложность координации между контекстами
- Необходимость поддержания целостности агрегатов

### Рассмотренные альтернативы
1. **Традиционный слоистый подход (N-слойная архитектура):** Отклонен из-за недостаточной гибкости и проблем с масштабированием команд.
2. **Только микросервисы без DDD:** Отклонен из-за риска создания distributed monolith.
3. **Event Storming с последующим DDD:** Рассмотрен и принят как часть процесса проектирования.

### Связанные решения
- ADR-001 (Микросервисная архитектура)
- ADR-012 (Стратегия выделения ограниченных контекстов)
- ADR-013 (Моделирование агрегатов и инвариантов)

---

## ADR-012: Выделение Core Domain и стратегия ограниченных контекстов

### Статус
Принято (2024-01-21)

### Контекст
В рамках DDD подхода необходимо определить Core Domain (смысловое ядро) и стратегию разделения системы на ограниченные контексты.

### Решение
Определить Core Domain как **User & Social Context**, так как социальная вовлеченность и формирование комьюнити является основной бизнес-ценностью приложения.

Стратегия ограниченных контекстов:
1. **User & Social Context (Core):** Управление пользователями, социальным графом, группами
2. **Activity & Training Context (Supporting):** Тренировки, упражнения, метрики
3. **Health & Device Context (Supporting):** Медицинские данные, интеграция устройств
4. **Commerce & Recommendations Context (Supporting):** Продажи, рекомендации, промоакции

### Последствия
**Положительные:**
- Фокус ресурсов на наиболее важной части системы
- Четкое разделение зон ответственности команд
- Упрощение коммуникации через единый язык в каждом контексте
- Возможность разного темпа развития для разных контекстов

**Отрицательные:**
- Риск неправильного выделения границ контекстов
- Необходимость координации между командами Core и Supporting доменов
- Сложность управления зависимостями между контекстами
- Потенциальная избыточность данных между контекстами

### Рассмотренные альтернативы
1. **Activity как Core Domain:** Отклонен, так как социальная компонента является дифференцирующим фактором.
2. **Не выделять Core Domain:** Отклонен, так как это приводит к распылению ресурсов.
3. **Более детальное разделение (7+ контекстов):** Отклонен из-за чрезмерной сложности для MVP.

### Связанные решения
- ADR-011 (Применение DDD)
- ADR-013 (Моделирование агрегатов)

---
## ADR-013: Моделирование агрегатов и бизнес-валидация

### Статус
Принято (2024-01-22)

### Контекст
Для каждого ограниченного контекста необходимо определить агрегаты с инкапсулированной бизнес-логикой и валидацией.

### Решение
Смоделировать ключевые агрегаты с четкими инвариантами:

**User & Social Context:**
- `User` (агрегат-корень): инвариант - максимум 5000 друзей
- `SocialGroup`: инвариант - минимальный возраст участников 16 лет

**Activity & Training Context:**
- `TrainingSession`: бизнес-правила валидации ЧСС, GPS, калорий
- `TrainingPlan`: инвариант - непротиворечивость расписания

**Health & Device Context:**
- `HealthMetric`: валидация по медицинским стандартам
- `Device`: калибровка и проверка точности данных

**Commerce & Recommendations Context:**
- `Product`: проверка совместимости с тренировочными планами
- `Recommendation`: правила персонализации (70% история, 30% социальный граф)

### Последствия
**Положительные:**
- Инкапсуляция сложности бизнес-правил
- Гарантия целостности данных на уровне агрегатов
- Упрощение тестирования бизнес-логики
- Четкое разделение ответственности

**Отрицательные:**
- Сложность проектирования границ агрегатов
- Риск создания слишком крупных агрегатов
- Необходимость тщательного проектирования транзакций
- Потенциальные проблемы с производительностью

### Рассмотренные альтернативы
1. **Анемичная модель:** Отклонена из-за рассеивания бизнес-логики по сервисам.
2. **Крупные агрегаты:** Отклонены из-за проблем с конкурентным доступом.
3. **Event Sourcing для всех агрегатов:** Отклонен как избыточный для MVP.

### Связанные решения
- ADR-011 (Применение DDD)
- ADR-014 (Стратегия обработки доменных событий)

---

## ADR-014: Стратегия интеграции между ограниченными контекстами

### Статус
Принято (2024-01-23)

### Контекст
Ограниченные контексты должны взаимодействовать друг с другом, сохраняя при этом свою автономию.

### Решение
Применить комбинированную стратегию интеграции:

1. **Асинхронная коммуникация через события:**
   - Доменные события через Apache Kafka
   - Eventual consistency между контекстами

2. **REST API для синхронных операций:**
   - Для операций, требующих немедленного ответа
   - С применением Circuit Breaker

3. **Типы связей между контекстами:**
   - Partnership между User & Social и Activity & Training
   - Customer-Supplier между Activity и Health & Devices
   - Conformist для интеграции с внешними системами

### Последствия
**Положительные:**
- Сохранение автономии контекстов
- Улучшенная отказоустойчивость
- Возможность независимого масштабирования
- Поддержка разных циклов разработки

**Отрицательные:**
- Сложность поддержания согласованности данных
- Необходимость обработки дублирующихся событий
- Сложность отладки распределенных транзакций
- Дополнительные накладные расходы на сериализацию

### Рассмотренные альтернативы
1. **Синхронная RPC для всей системы:** Отклонена из-за сильного связывания.
2. **Shared Database:** Отклонена как нарушающая принципы DDD.
3. **Дублирование данных без четкой стратегии:** Отклонена как опасная и приводящая к неконсистентности.

### Связанные решения
- ADR-002 (Apache Kafka)
- ADR-004 (Protocol Buffers)
- ADR-008 (Circuit Breaker)

---
## ADR-015: Использование Idempotency-Key для критических операций

### Статус
Принято (2024-01-24)

### Контекст
Критические операции (покупки, бронирования, регистрации) должны быть защищены от дублирования при сетевых сбоях и повторных запросах. Пользователи могут непреднамеренно повторять операции из-за нестабильного соединения.

### Решение
Использовать Idempotency-Key (идентификатор идемпотентности) в заголовках HTTP-запросов для всех критических операций:
- Покупки товаров (Commerce Context)
- Бронирование мест на событиях (Event Context)
- Регистрация на соревнования (Social Context)
- Обновление медицинских данных (Health Context)

### Последствия
**Положительные:**
- Гарантия идемпотентности операций при повторах
- Предотвращение двойных списаний, бронирований, регистраций
- Упрощение клиентской логики (безопасные ретраи)
- Стандартизация подхода ко всем критическим операциям

**Отрицательные:**
- Увеличение размера заголовков запросов
- Необходимость хранения состояния обработки ключей (TTL 24 часа)
- Сложность генерации уникальных ключей на клиенте
- Необходимость обработки конфликтов ключей

### Рассмотренные альтернативы
1. **Идемпотентность на уровне бизнес-логики:** Отклонена из-за сложности реализации и рисков рассинхронизации.
2. **Токены в теле запроса:** Отклонены из-за меньшей стандартизации и сложности кэширования.
3. **Зависимость от транзакционных ID БД:** Отклонена из-за связывания с конкретной реализацией БД.

### Связанные решения
- ADR-016 (TTL-резервирования)
- ADR-017 (Компенсирующие транзакции)
- ADR-002 (Apache Kafka для обработки событий)

---

## ADR-016: Стратегия TTL-резервирований для временных данных

### Статус
Принято (2024-01-25)

### Контекст
Временные резервирования (корзины, бронирования мест, ценовые сессии) должны автоматически освобождаться по истечении времени для предотвращения deadlocks и неэффективного использования ресурсов.

### Решение
Реализовать универсальный механизм TTL (Time-To-Live) резервирований:
- Корзины покупок: TTL 24 часа
- Резервирование товаров: TTL 30 минут
- Бронирование мест: TTL 15 минут
- Ценовые сессии: TTL 15 минут

### Последствия
**Положительные:**
- Автоматическое освобождение ресурсов при истечении времени
- Предотвращение deadlocks и зависших резервирований
- Улучшение пользовательского опыта (ясные таймауты)
- Снижение нагрузки на систему за счет автоматической очистки

**Отрицательные:**
- Необходимость фоновых процессов для очистки
- Риск преждевременного освобождения при сетевых задержках
- Сложность настройки оптимальных TTL для разных сценариев
- Дополнительная нагрузка на базу данных

### Рассмотренные альтернативы
1. **Ручное освобождение ресурсов:** Отклонено из-за риска утечек ресурсов и сложности реализации.
2. **Fixed-time очистка (например, раз в сутки):** Отклонено из-за неэффективного использования ресурсов.
3. **Аренда ресурсов с периодическим обновлением:** Рассмотрено, но отклонено из-за сложности клиентской логики.

### Связанные решения
- ADR-015 (Idempotency-Key для согласованности)
- ADR-017 (Компенсирующие транзакции для отката)
- ADR-003 (Полиглотная стратегия хранения данных)

---
## ADR-017: Компенсирующие транзакции для отката распределенных операций

### Статус
Принято (2024-01-26)

### Контекст
В распределенной микросервисной архитектуре отсутствует поддержка ACID-транзакций между сервисами. При сбоях в цепочке операций необходимо обеспечить согласованность данных через откат выполненных шагов.

### Решение
Реализовать паттерн компенсирующих транзакций (Saga pattern) для критических бизнес-процессов:
- Покупка товара с резервированием и оплатой
- Бронирование места с последующей оплатой
- Регистрация на событие с проверкой квот

### Последствия
**Положительные:**
- Обеспечение согласованности данных при распределенных сбоях
- Возможность отката без блокировок на уровне всей системы
- Поддержка длительных бизнес-транзакций
- Улучшенная отказоустойчивость системы

**Отрицательные:**
- Сложность проектирования компенсирующих действий
- Риск неполного отката при каскадных сбоях
- Необходимость хранения состояния компенсаций
- Потенциальные расхождения при неустранимых ошибках

### Рассмотренные альтернативы
1. **Двухфазный коммит (2PC):** Отклонен из-за проблем с производительностью и доступностью.
2. **Event Sourcing с полным реплеем:** Отклонен как избыточный для большинства сценариев.
3. **Бизнес-компенсации вручную:** Отклонен из-за высокой стоимости ошибок и необходимости человеческого вмешательства.

### Связанные решения
- ADR-002 (Apache Kafka для координации саг)
- ADR-015 (Idempotency-Key для предотвращения дублей)
- ADR-018 (Пессимистические блокировки для ресурсов)

---

## ADR-018: Пессимистические блокировки для управления ресурсами

### Статус
Принято (2024-01-27)

### Контекст
Критические ресурсы с ограниченной емкостью (места на событиях, товары со складскими остатками) требуют строгой синхронизации доступа для предотвращения двойного бронирования/продажи.

### Решение
Использовать пессимистические блокировки на уровне базы данных для операций с ограниченными ресурсами:
- `SELECT FOR UPDATE` в PostgreSQL для бронирования мест
- Оптимистичные блокировки через версионирование для менее критичных ресурсов
- Redis distributed locks для координации между экземплярами сервисов

### Последствия
**Положительные:**
- Гарантированная целостность данных при конкурентном доступе
- Предотвращение двойного расходования ограниченных ресурсов
- Простота реализации и понимания
- Хорошая производительность при умеренной конкуренции

**Отрицательные:**
- Риск взаимных блокировок (deadlocks)
- Снижение производительности при высокой конкуренции
- Увеличение времени отклика для пользователей
- Сложность отладки блокировок в распределенной системе

### Рассмотренные альтернативы
1. **Оптимистические блокировки:** Отклонены для критических ресурсов из-за риска частых конфликтов.
2. **Очереди запросов с последовательной обработкой:** Отклонены из-за неприемлемой задержки для пользователей.
3. **Резервирование с последующей проверкой:** Отклонено из-за риска перепродажи.

### Связанные решения
- ADR-003 (PostgreSQL для транзакционных данных)
- ADR-016 (TTL для автоматического освобождения блокировок)
- ADR-017 (Компенсирующие транзакции при ошибках)

---
## ADR-019: Массовая обработка с батчингом для глобальных событий

### Статус
Принято (2024-01-28)

### Контекст
Глобальные соревнования и события могут привлекать десятки тысяч одновременных регистраций. Прямая обработка каждого запроса в реальном времени может привести к перегрузке системы и деградации производительности.

### Решение
Реализовать механизм массовой обработки с батчингом для пиковых нагрузок:
- Буферизация запросов в Apache Kafka
- Батчевая обработка по 1000 запросов за раз
- Auto-scaling воркеров на основе длины очереди
- Приоритизация запросов по времени получения

### Последствия
**Положительные:**
- Обработка пиковых нагрузок без деградации сервиса
- Эффективное использование ресурсов за счет батчинга
- Возможность внедрения сложной логики обработки
- Улучшенная предсказуемость производительности

**Отрицательные:**
- Увеличение задержки обработки для пользователей
- Сложность обработки частичных сбоев в батче
- Необходимость механизмов отслеживания статуса запросов
- Дополнительная сложность в отладке и мониторинге

### Рассмотренные альтернативы
1. **Прямая обработка с горизонтальным масштабированием:** Отклонена из-за квадратичного роста нагрузки на базу данных.
2. **Шардирование по пользователям/регионам:** Рассмотрено как дополнение, но недостаточное для экстремальных нагрузок.
3. **Лотерея или случайный отбор:** Отклонено как неприемлемое с точки зрения пользовательского опыта.

### Связанные решения
- ADR-002 (Apache Kafka как буфер)
- ADR-006 (Kubernetes для auto-scaling)
- ADR-015 (Idempotency-Key для избежания дублей)

---
---
## ADR-020: Внедрение Event Sourcing для Order Service

### Статус
Принято (2024-02-01)

### Контекст
Требуется полная аудируемость операций с заказами и возможность восстановления состояния системы из событий. Бизнес-требования включают:
- Анализ воронки продаж от первого визита до повторной покупки
- Понимание причин отмен заказов на каждом этапе
- Оптимизация времени на этапах заказа
- Сегментация клиентов по поведенческим паттернам

### Решение
Применить Event Sourcing для Order Service:
- Сохранение всех изменений состояния заказа как последовательности событий
- Восстановление текущего состояния через применение событий
- Использование snapshot'ов для оптимизации производительности
- Публикация доменных событий для других сервисов

### Последствия
**Положительные:**
- Полная история изменений каждого заказа
- Возможность анализировать поведение пользователей в воронке продаж
- Легкая интеграция с аналитикой через чтение событий
- Возможность отката к любому предыдущему состоянию
- Упрощение отладки и аудита

**Отрицательные:**
- Усложнение чтения текущего состояния (требуется применение событий)
- Увеличение объема хранимых данных (события + snapshots)
- Сложность миграции существующих данных
- Необходимость обработки устаревших событий при изменении схемы

### Рассмотренные альтернативы
1. **CRUD-модель с таблицей изменений:** Отклонена из-за частичной потери контекста изменений.
2. **Двойная запись (события + состояние):** Рассмотрена, но отклонена из-за риска рассинхронизации.
3. **Change Data Capture (CDC):** Отклонена как недостаточно гибкая для бизнес-событий.

### Связанные решения
- ADR-002 (Apache Kafka для публикации событий)
- ADR-011 (Применение DDD для моделирования)
- ADR-023 (Actor Model для агрегатов)

---

## ADR-021: Выделение Inventory Service для управления запасами

### Статус
Принято (2024-02-01)

### Контекст
Управление остатками товаров требует независимого масштабирования и отдельной бизнес-логики. Order Service становится перегруженным, совмещая управление заказами и запасами.

### Решение
Выделить Inventory Service как отдельный микросервис с ответственностью за:
- Управление остатками товаров на складах
- Резервирование товаров для заказов
- Синхронизацию запасов между регионами
- Автоматическое освобождение резервов по TTL

### Последствия
**Положительные:**
- Независимое масштабирование управления запасами
- Четкое разделение ответственности (Single Responsibility)
- Возможность оптимизации под специфичные сценарии (пиковые нагрузки)
- Упрощение Order Service (снижение когнитивной нагрузки)
- Улучшенная отказоустойчивость (изоляция сбоев)

**Отрицательные:**
- Необходимость распределенных транзакций с Order Service
- Усложнение архитектуры (еще один сервис)
- Дополнительные сетевые вызовы
- Необходимость синхронизации данных (eventual consistency)

### Рассмотренные альтернативы
1. **Хранение запасов в Order Service:** Отклонено из-за проблем с масштабированием и смешения ответственности.
2. **Совместная база данных с Order Service:** Отклонено как нарушающее границы микросервисов.
3. **Event-driven обновление запасов без отдельного сервиса:** Рассмотрено, но отклонено из-за сложности координации.

### Связанные решения
- ADR-015 (Idempotency-Key для резервирований)
- ADR-016 (TTL для автоматического освобождения)
- ADR-017 (Компенсирующие транзакции)

---

## ADR-022: Создание Analytics Service с CQRS-архитектурой

### Статус
Принято (2024-02-01)

### Контекст
Требуется аналитика в реальном времени без нагрузки на транзакционные базы данных. Бизнес нуждается в:
- Real-time дашбордах для оперативного принятия решений
- A/B тестировании функциональности
- Прогнозировании спроса на основе исторических данных
- Глубоком анализе пользовательского поведения

### Решение
Создать Analytics Service на основе CQRS (Command Query Responsibility Segregation):
- **Write side:** Прием событий из других сервисов через Kafka
- **Read side:** Оптимизированные read models в ClickHouse для аналитических запросов
- **Отдельные модели:** Разные модели для записи и чтения, оптимизированные под свои задачи
- **Eventual consistency:** Асинхронное обновление read models

### Последствия
**Положительные:**
- Высокая производительность аналитических запросов
- Изоляция аналитической нагрузки от транзакционных систем
- Гибкость в выборе хранилищ для разных типов аналитики
- Возможность построения сложных агрегаций без влияния на основное приложение
- Легкое масштабирование read side независимо от write side

**Отрицательные:**
- Eventual consistency аналитических данных (задержка до секунд/минут)
- Усложнение архитектуры (два хранилища, синхронизация)
- Дублирование данных (одни данные в нескольких оптимизированных форматах)
- Сложность обеспечения транзакционности между write и read моделями

### Рассмотренные альтернативы
1. **Запросы напрямую к транзакционным БД:** Отклонено из-за нагрузки на основные системы.
2. **Периодические ETL-процессы:** Отклонено из-за отсутствия real-time аналитики.
3. **Совместное использование БД с другими сервисами:** Отклонено как нарушающее изоляцию.

### Связанные решения
- ADR-002 (Apache Kafka для передачи событий)
- ADR-003 (Полиглотное хранение - добавление ClickHouse)
- ADR-020 (Event Sourcing как источник событий)

---

## ADR-023: Использование Actor Model для реализации агрегатов

### Статус
Принято (2024-02-01)

### Контекст
Требуется гарантированная однопоточность обработки команд для каждого агрегата в Event Sourcing. Необходимо эффективное управление состоянием агрегатов в памяти с устойчивостью к сбоям.

### Решение
Реализовать агрегаты на основе Actor Model (Akka):
- Каждый агрегат (Order, Payment, ProductStock) представлен как Actor
- Гарантированная однопоточность обработки команд для каждого агрегата
- Автоматическое управление состоянием в памяти
- Устойчивость к сбоям через supervision hierarchies
- Легкое горизонтальное масштабирование через sharding

### Последствия
**Положительные:**
- Гарантированная консистентность на уровне агрегата
- Высокая производительность за счет in-memory обработки
- Автоматическое восстановление после сбоев
- Легкое распределение нагрузки (sharding акторов)
- Естественное соответствие DDD-агрегатам

**Отрицательные:**
- Сложность отладки распределенных акторов
- Кривая обучения для команды (новые парадигмы)
- Риск потери in-memory состояния при сбоях (требует persistence)
- Сложность миграции с традиционного подхода
- Дополнительная инфраструктура (Akka Cluster)

### Рассмотренные альтернативы
1. **Традиционные сервисы с блокировками в БД:** Отклонено из-за проблем с производительностью и сложностью.
2. **Реализация на основе проекций (Projections):** Рассмотрено, но отклонено как менее эффективное для команд.
3. **Использование оркестраторов (Workflow engines):** Отклонено как избыточное для простых агрегатов.

### Связанные решения
- ADR-011 (Применение DDD - агрегаты как границы консистентности)
- ADR-020 (Event Sourcing - акторы как хранители состояния)
- ADR-002 (Kafka для коммуникации между акторами)

---

## ADR-024: Разделение потоков событий по логической принадлежности

### Статус
Принято (2024-02-01)

### Контекст
Разные типы событий имеют разные требования к обработке, хранению и безопасности. Смешение всех событий в одном потоке усложняет:
- Управление доступом к данным
- Оптимизацию под разные паттерны доступа
- Изоляцию проблем (сбой в одном потоке не должен влиять на другие)
- Соответствие регуляторным требованиям

### Решение
Разделить события на три независимых потока:
1. **Бизнес-события (Kafka topics):**
   - `orders.events` - для аналитики воронок и поведения
   - `payments.events` - для финансовой отчетности и аудита
   - `inventory.events` - для управления остатками и аналитики склада

2. **Технические события (Kafka topics):**
   - `metrics.events` - для мониторинга производительности и здоровья
   - `audit.events` - для compliance и безопасности
   - `system.events` - для системных уведомлений и алертинга

3. **Логи приложений (ELK stack):**
   - `application.logs` - для отладки бизнес-логики
   - `access.logs` - для анализа трафика и безопасности
   - `error.logs` - для отслеживания ошибок и исключений

### Последствия
**Положительные:**
- Изоляция проблем в одном потоке не влияет на другие
- Оптимизация под разные паттерны доступа (retention, partitioning)
- Независимое масштабирование обработчиков для каждого типа событий
- Разные уровни безопасности и доступа к данным
- Упрощение compliance (разделение чувствительных данных)

**Отрицательные:**
- Увеличение сложности управления (больше топиков, потребителей)
- Потенциальная дубликация данных между потоками
- Сложность обеспечения согласованности между разными потоками
- Увеличение накладных расходов на инфраструктуру

### Рассмотренные альтернативы
1. **Единый поток всех событий:** Отклонено из-за проблем с изоляцией и оптимизацией.
2. **Разделение по сервисам-источникам:** Рассмотрено, но отклонено как менее логичное (один сервис может генерировать разные типы событий).
3. **Разделение по критичности:** Отклонено как недостаточно детальное.

### Связанные решения
- ADR-002 (Apache Kafka как платформа для событий)
- ADR-009 (OpenTelemetry для технических событий)
- ADR-022 (Analytics Service как потребитель бизнес-событий)

----

---
## ADR-025: Дифференцированные стратегии обработки ошибок в микросервисных интеграциях

### Статус
Принято (2024-02-02)

### Контекст
Микросервисная архитектура включает различные типы интеграций с разными требованиями к надежности:
- Синхронные HTTP-вызовы для операций, требующих немедленного ответа пользователю (оплата, бронирование)
- Асинхронные операции через очереди для гарантированной обработки (резервирование, уведомления)
- Интеграции с внешними сервисами с разной степенью надежности (платежные шлюзы, картографические сервисы)

Необходимо предотвратить каскадные отказы, обеспечить отказоустойчивость системы и гарантировать обработку критичных бизнес-операций.

### Решение
Применить дифференцированный подход к обработке ошибок на основе бизнес-критичности операций:

1. **Для синхронных HTTP/REST интеграций (Circuit Breaker + Retry + Fallback):**
   - **Circuit Breaker:** 5 ошибок за 60 секунд → состояние OPEN на 30 секунд
   - **Retry с экспоненциальной задержкой:** 2 попытки (1s, 3s) для временных ошибок
   - **Fallback механизмы:** Кешированные данные, альтернативные провайдеры, graceful degradation

2. **Для асинхронных операций через очереди (Retry + DLQ + Компенсирующие транзакции):**
   - **Retry с exponential backoff:** 30s → 2m → 5m (максимум 3 попытки)
   - **Dead Letter Queue:** Изоляция проблемных сообщений после 3 неудачных попыток
   - **Автоматический откат:** Компенсирующие транзакции через события

3. **Для внешних интеграций с низкой надежностью:**
   - **Агрессивный Circuit Breaker:** 3 ошибки за 30 секунд
   - **Graceful degradation:** Локальные расчеты при недоступности внешних сервисов
   - **Мульти-провайдерские fallback:** Резервные провайдеры (Stripe → PayPal → банковский перевод)

### Последствия
**Положительные:**
- Предотвращение каскадных отказов в системе
- Гарантированная обработка критичных бизнес-операций
- Минимальное влияние сбоев на пользовательский опыт
- Улучшенная наблюдаемость состояния интеграций
- Автоматическое восстановление при временных сбоях

**Отрицательные:**
- Увеличение сложности реализации сервисов
- Необходимость поддержки нескольких паттернов обработки ошибок
- Дополнительные ресурсы для мониторинга и алертинга
- Eventual consistency для некоторых операций при использовании fallback

### Рассмотренные альтернативы
1. **Единая стратегия для всех интеграций:** Отклонена из-за разных требований к надежности и задержкам.
2. **Агрессивные retry без ограничений:** Отклонена из-за риска создания дополнительной нагрузки на проблемные сервисы.
3. **Ручная обработка всех сбоев:** Отклонена как непрактичная в масштабе распределенной системы.
4. **Только Circuit Breaker без fallback:** Отклонена из-за негативного влияния на пользовательский опыт.

### Связанные решения
- ADR-002 (Apache Kafka для асинхронной обработки)
- ADR-008 (Circuit Breaker для внешних сервисов)
- ADR-015 (Idempotency-Key для предотвращения дублей)
- ADR-017 (Компенсирующие транзакции для отката)

---------------
## Матрица статусов ADR

| ADR | Статус | Дата принятия | Ответственный | Связанные сценарии |
|-----|--------|---------------|----------------|-------------------|
| ADR-001 | Принято | 2024-01-15 | Ведущий архитектор | Все |
| ADR-002 | Принято | 2024-01-15 | Архитектор бэкенда | UC-003, UC-004, UC-010 |
| ADR-003 | Принято | 2024-01-16 | Архитектор данных | Все |
| ADR-004 | Принято | 2024-01-16 | Архитектор бэкенда | Все |
| ADR-005 | Принято | 2024-01-17 | Архитектор инфраструктуры | Все глобальные |
| ADR-006 | Принято | 2024-01-17 | DevOps Lead | Все |
| ADR-007 | Принято | 2024-01-18 | Ведущий архитектор | Все |
| ADR-008 | Принято | 2024-01-18 | Архитектор бэкенда | UC-003, UC-004 |
| ADR-009 | Принято | 2024-01-19 | DevOps Lead | Все |
| ADR-010 | Принято | 2024-01-19 | Архитектор фронтенда | Все клиентские |
| ADR-011 | Принято | 2024-01-20 | Ведущий архитектор | Все |
| ADR-012 | Принято | 2024-01-21 | DDD Lead | Все |
| ADR-013 | Принято | 2024-01-22 | Архитектор бэкенда | Все |
| ADR-014 | Принято | 2024-01-23 | Архитектор интеграций | Все |
| ADR-015 | Принято | 2024-01-24 | Архитектор бэкенда | UC-003, UC-004, UC-010 |
| ADR-016 | Принято | 2024-01-25 | Архитектор данных | UC-003, UC-004 |
| ADR-017 | Принято | 2024-01-26 | Архитектор бэкенда | UC-003, UC-004, UC-010 |
| ADR-018 | Принято | 2024-01-27 | Архитектор бэкенда | UC-004 |
| ADR-019 | Принято | 2024-01-28 | Архитектор инфраструктуры | UC-010 |
| ADR-019 | Принято | 2024-01-28 | Архитектор инфраструктуры | UC-010 |
| ADR-020 | Принято | 2024-02-01 | Архитектор событийной модели | UC-003, UC-004, UC-006 |
| ADR-021 | Принято | 2024-02-01 | Архитектор микросервисов | UC-003, UC-004 |
| ADR-022 | Принято | 2024-02-01 | Архитектор аналитики | UC-007, UC-008, UC-009 |
| ADR-023 | Принято | 2024-02-01 | Архитектор бэкенда | UC-003, UC-004 |
| ADR-024 | Принято | 2024-02-01 | Архитектор инфраструктуры | Все |
| ADR-025 | Принято | 2024-02-02 | Архитектор надежности | UC-003, UC-004, UC-006, UC-010 |
---

## Процесс управления ADR

1. **Создание:** Любой член команды может предложить ADR, создав черновик в репозитории.
2. **Обсуждение:** ADR обсуждается на архитектурном комитете или в pull request.
3. **Принятие:** Решение принимается консенсусом или, при необходимости, голосованием.
4. **Реализация:** Принятые ADR реализуются в соответствующем порядке приоритетов.
5. **Обзор:** ADR периодически пересматриваются на актуальность (каждые 6 месяцев).
6. **Архивация:** Устаревшие ADR помечаются как deprecated с указанием заменяющего решения.

## Связь с бизнес-целями

| ADR | Бизнес-цель 1 | Бизнес-цель 2 | Бизнес-цель 3 | Бизнес-цель 4 |
|-----|---------------|---------------|---------------|---------------|
| ADR-001 | ✓ | ✓ | ✓ | ✓ |
| ADR-002 | ✓ | ✓ | ✓ | |
| ADR-003 | ✓ | ✓ | ✓ | ✓ |
| ADR-004 | ✓ | | ✓ | ✓ |
| ADR-005 | ✓ | | ✓ | ✓ |
| ADR-006 | | | | ✓ |
| ADR-007 | | | | ✓ |
| ADR-008 | | ✓ | | ✓ |
| ADR-009 | | | | ✓ |
| ADR-010 | ✓ | ✓ | | |
| ADR-011 | ✓ | | ✓ | |
| ADR-012 | ✓ | | ✓ | |
| ADR-013 | ✓ | ✓ | ✓ | |
| ADR-014 | ✓ | | ✓ | |
| ADR-015 | | ✓ | | ✓ |
| ADR-016 | | ✓ | | ✓ |
| ADR-017 | | ✓ | | ✓ |
| ADR-018 | | ✓ | | |
| ADR-019 | ✓ | | | ✓ |
| ADR-020 | ✓ | ✓ | ✓ | ✓ |
| ADR-021 | | ✓ | | ✓ |
| ADR-022 | ✓ | ✓ | ✓ | ✓ |
| ADR-023 | | | | ✓ |
| ADR-024 | | | | ✓ |
| ADR-025 | ✓ | ✓ | | ✓ |

**Легенда:**
- **Бизнес-цель 1:** Увеличение вовлеченности пользователей и времени взаимодействия с брендом
- **Бизнес-цель 2:** Стимулирование продаж через интегрированные промоакции
- **Бизнес-цель 3:** Создание устойчивого комьюнити и социального влияния
- **Бизнес-цель 4:** Укрепление позиции бренда как технологического лидера


