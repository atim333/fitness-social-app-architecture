# 11. Архитектурные решения (ADR - Architectural Decision Records)

## Обзор
Architectural Decision Records (ADR) документируют ключевые архитектурные решения, принятые в проекте, их контекст, последствия и статус.

## Формат ADR
Каждое ADR следует шаблону:
- **Title:** Идентификатор и краткое описание решения
- **Status:** Предложено/Принято/Устарело
- **Context:** Проблема или возможность, требующая решения
- **Decision:** Принятое решение
- **Consequences:** Последствия (положительные и отрицательные)
- **Alternatives Considered:** Рассмотренные альтернативы
- **Related Decisions:** Связанные решения

---

## ADR-001: Выбор микросервисной архитектуры с постепенной миграцией

### Статус
Принято (2024-01-15)

### Контекст
Необходимо разработать фитнес-социальное приложение, которое должно:
- Масштабироваться до миллионов пользователей по всему миру
- Поддерживать независимые циклы разработки для разных функциональных блоков
- Интегрироваться с разнородными внешними системами
- Обслуживать пользователей в регионах с разной инфраструктурой

### Решение
Принять гибридный подход: начать с четко модулизированного монолита (модульный монолит) для MVP, с планом постепенного выделения сервисов в микросервисы по мере роста нагрузки и команды.

### Последствия
**Положительные:**
- Ускорение выхода MVP (меньше накладных расходов на инфраструктуру)
- Упрощенная отладка и тестирование на начальных этапах
- Возможность пересмотреть границы сервисов после получения обратной связи
- Меньшие требования к квалификации команды на старте

**Отрицательные:**
- Необходимость планирования миграции с самого начала
- Дополнительные усилия на рефакторинг при выделении сервисов
- Временное ограничение в независимом масштабировании компонентов

### Рассмотренные альтернативы
1. **Чистый монолит:** Отклонен из-за проблем с масштабированием и независимостью развертывания.
2. **Полные микросервисы с первого дня:** Отклонен из-за высокой сложности и накладных расходов для MVP.
3. **Serverless-архитектура:** Рассмотрен, но отклонен из-за требований к stateful-операциям и потенциальным проблемам с холодным стартом.

### Связанные решения
- ADR-002 (Выбор событийной шины)
- ADR-003 (Стратегия хранения данных)
- ADR-007 (Стратегия развертывания)

---

## ADR-002: Использование Apache Kafka в качестве событийной шины

### Статус
Принято (2024-01-15)

### Контекст
Требуется обеспечить асинхронную коммуникацию между сервисами для:
- Обработки социальных событий (лайки, комментарии, уведомления)
- Синхронизации данных между сервисами в eventual consistency модели
- Обеспечения отказоустойчивости при временной недоступности сервисов
- Поддержки обработки потока данных с фитнес-устройств

### Решение
Использовать Apache Kafka в качестве основной событийной шины для асинхронной коммуникации между сервисами.

### Последствия
**Положительные:**
- Высокая пропускная способность (миллионы сообщений в секунду)
- Гарантированная доставка сообщений
- Поддержка реигрывания событий (replay)
- Широкие возможности масштабирования (партиции, репликация)
- Интеграция с экосистемой обработки данных (Kafka Streams, Connect)

**Отрицательные:**
- Сложность настройки и эксплуатации кластера Kafka
- Дополнительная инфраструктурная компонента для поддержки
- Кривая обучения для команды
- Необходимость управления схемами сообщений (Schema Registry)

### Рассмотренные альтернативы
1. **RabbitMQ:** Отклонен из-за меньшей производительности при больших объемах данных.
2. **AWS SNS/SQS:** Рассмотрен для облачных развертываний, но отклонен из-за vendor lock-in и требований к мультиоблачности.
3. **NATS:** Рассмотрен, но отклонен из-за менее развитой экосистемы и меньшей гарантии доставки.

### Связанные решения
- ADR-004 (Формат сериализации сообщений)
- ADR-008 (Стратегия обработки ошибок)

---

## ADR-003: Полиглотная стратегия хранения данных

### Статус
Принято (2024-01-16)

### Контекст
Различные типы данных в приложении имеют разные требования:
- **Профили пользователей:** Транзакционность, сложные запросы
- **Социальный граф:** Графовые операции, поиск связей
- **Тренировки и телеметрия:** Запись временных рядов, большие объемы
- **Кэш и сессии:** Низкая задержка, высокая доступность
- **Поиск и агрегации:** Полнотекстовый поиск, сложные агрегации

### Решение
Использовать полиглотное хранение данных с выбором оптимальной базы данных для каждого типа данных:
1. **PostgreSQL** для транзакционных данных (пользователи, заказы)
2. **Neo4j** для социального графа
3. **Cassandra** для данных тренировок (телеметрия)
4. **Redis** для кэша и сессий
5. **Elasticsearch** для поиска и аналитики

### Последствия
**Положительные:**
- Оптимальная производительность для каждого типа операций
- Возможность независимого масштабирования хранилищ
- Использование сильных сторон каждой технологии

**Отрицательные:**
- Сложность управления несколькими системами
- Необходимость синхронизации данных между разными хранилищами
- Повышенные требования к экспертизе команды
- Усложнение резервного копирования и восстановления

### Рассмотренные альтернативы
1. **Единая SQL база:** Отклонен из-за проблем с масштабированием и разнородностью данных.
2. **Единая NoSQL база:** Отклонен из-за недостаточной транзакционности и сложности графовых операций.
3. **Новый SQL (CockroachDB, TiDB):** Рассмотрен, но отклонен из-за недостаточной зрелости для графовых операций.

### Связанные решения
- ADR-005 (Стратегия репликации и шардирования)
- ADR-009 (Стратегия резервного копирования)

---

## ADR-004: Использование Protocol Buffers для сериализации сообщений

### Статус
Принято (2024-01-16)

### Контекст
Требуется эффективный формат сериализации для:
- Межсервисной коммуникации (gRPC)
- Сообщений в Apache Kafka
- Долгосрочного хранения событий в логе

### Решение
Использовать Protocol Buffers (protobuf) в качестве основного формата сериализации для всех межсервисных коммуникаций и сообщений в Kafka.

### Последствия
**Положительные:**
- Высокая производительность (меньший размер сообщений, быстрая сериализация)
- Строгая типизация и схема сообщений
- Поддержка версионирования схем
- Широкая поддержка в различных языках программирования
- Интеграция с gRPC

**Отрицательные:**
- Необходимость поддержки файлов .proto в репозитории
- Дополнительный шаг компиляции при сборке
- Менее человекочитаемый формат по сравнению с JSON

### Рассмотренные альтернативы
1. **JSON:** Отклонен из-за большего размера сообщений и отсутствия строгой схемы.
2. **Avro:** Рассмотрен, но отклонен из-за меньшей производительности и более слабой поддержки в некоторых языках.
3. **XML:** Отклонен из-за большого размера и сложности парсинга.

### Связанные решения
- ADR-002 (Использование Apache Kafka)
- ADR-010 (Стратегия API Gateway)

---

## ADR-005: Геошардирование данных по регионам

### Статус
Принято (2024-01-17)

### Контекст
Приложение должно обслуживать пользователей по всему миру с минимальной задержкой. Пользовательские данные должны быть доступны быстро, независимо от местоположения пользователя.

### Решение
Реализовать геошардирование данных, где данные пользователей хранятся в регионе, ближайшем к их основному местоположению.

### Последствия
**Положительные:**
- Низкая задержка доступа к данным для пользователей
- Соответствие требованиям GDPR и другим регуляторным нормам
- Уменьшение трансграничного трафика данных
- Возможность независимого масштабирования по регионам

**Отрицательные:**
- Сложность кросс-региональных запросов (друзья в разных регионах)
- Усложнение миграции пользователей между регионами
- Необходимость репликации глобальных данных (каталог товаров, промоакции)
- Усложнение аналитики по всем регионам

### Рассмотренные альтернативы
1. **Единый глобальный кластер:** Отклонен из-за высокой задержки для удаленных регионов.
2. **Полная репликация во все регионы:** Отклонен из-за высоких затрат на хранение и сложности поддержания согласованности.
3. **Кэширование в регионах с мастером в одном:** Рассмотрен, но отклонен из-за требований GDPR к хранению данных в регионе.

### Связанные решения
- ADR-003 (Полиглотная стратегия хранения)
- ADR-011 (Стратегия репликации между регионами)

---

## ADR-006: Использование Kubernetes для оркестрации контейнеров

### Статус
Принято (2024-01-17)

### Контекст
Требуется платформа для оркестрации контейнеров, которая:
- Поддерживает мультиоблачное развертывание
- Обеспечивает автоматическое масштабирование
- Упрощает развертывание и управление микросервисами
- Поддерживает различные стратегии развертывания (canary, blue-green)

### Решение
Использовать Kubernetes в качестве основной платформы для оркестрации контейнеров во всех окружениях (dev, staging, production).

### Последствия
**Положительные:**
- Единая платформа для всех окружений
- Поддержка мультиоблачных развертываний
- Богатая экосистема инструментов и расширений
- Автоматическое масштабирование (HPA, VPA)
- Встроенные механизмы отказоустойчивости (health checks, readiness probes)

**Отрицательные:**
- Высокая сложность настройки и эксплуатации
- Требует значительных экспертных знаний
- Накладные расходы на управление кластером
- Сложность миграции существующих приложений

### Рассмотренные альтернативы
1. **Docker Swarm:** Отклонен из-за меньшей функциональности и экосистемы.
2. **AWS ECS/Fargate:** Рассмотрен для AWS, но отклонен из-за vendor lock-in и требований к мультиоблачности.
3. **Nomad:** Рассмотрен, но отклонен из-за меньшей распространенности и экосистемы.

### Связанные решения
- ADR-007 (Стратегия развертывания)
- ADR-012 (Стратегия мониторинга)

---

## ADR-007: Мультиоблачная стратегия развертывания

### Статус
Принято (2024-01-18)

### Контекст
Компания использует несколько облачных провайдеров (90% систем в облаке, нет единого провайдера). Требуется стратегия, которая:
- Избегает vendor lock-in
- Обеспечивает лучшую производительность в разных регионах
- Использует существующие скидки и соглашения компании

### Решение
Принять мультиоблачную стратегию с доминированием AWS, но с поддержкой других провайдеров (GCP, Azure) для специфических регионов или сервисов.

### Последствия
**Положительные:**
- Избежание зависимости от одного провайдера
- Использование лучших сервисов каждого провайдера
- Улучшение переговорной позиции с провайдерами
- Повышенная отказоустойчивость (провайдер как единая точка отказа)

**Отрицательные:**
- Высокая сложность управления
- Необходимость экспертизы в нескольких платформах
- Потенциально более высокие общие затраты
- Сложности с передачей данных между облаками

### Рассмотренные альтернативы
1. **Единый облачный провайдер (AWS):** Отклонен из-за риска vendor lock-in и возможных ограничений в некоторых регионах.
2. **Гибридное облако (on-premise + cloud):** Отклонен из-за высоких капитальных затрат и сложности масштабирования.
3. **Выбор провайдера по региону:** Рассмотрен, но принят как часть решения (GCP для Азии, AWS для остального мира).

### Связанные решения
- ADR-005 (Геошардирование данных)
- ADR-006 (Использование Kubernetes)

---

## ADR-008: Circuit Breaker для взаимодействия с внешними сервисами

### Статус
Принято (2024-01-18)

### Контекст
Приложение зависит от множества внешних сервисов (платежные системы, фитнес-устройства, картографические сервисы). Сбои во внешних сервисах не должны приводить к каскадным отказам в приложении.

### Решение
Реализовать паттерн Circuit Breaker для всех взаимодействий с внешними сервисами.

### Последствия
**Положительные:**
- Предотвращение каскадных отказов
- Улучшенная отказоустойчивость системы
- Быстрое обнаружение проблем во внешних сервисах
- Возможность graceful degradation функциональности

**Отрицательные:**
- Усложнение кода клиентов внешних сервисов
- Необходимость настройки параметров для каждого сервиса
- Риск ложных срабатываний

### Рассмотренные альтернативы
1. **Retry с экспоненциальной отсрочкой:** Рассмотрен как дополнение к Circuit Breaker, но не как замена.
2. **Bulkhead:** Рассмотрен для изоляции ресурсов, принят как дополнительная мера.
3. **Таймауты:** Рассмотрены как базовая мера, но недостаточные для полной защиты.

### Связанные решения
- ADR-002 (Использование Apache Kafka для асинхронной обработки)

---

## ADR-009: Использование OpenTelemetry для распределенного трейсинга

### Статус
Принято (2024-01-19)

### Контекст
В микросервисной архитектуре сложно отслеживать выполнение запросов, проходящих через несколько сервисов. Требуется решение для:
- Трассировки запросов через всю систему
- Измерения производительности отдельных компонентов
- Анализа зависимостей между сервисами

### Решение
Использовать OpenTelemetry в качестве стандарта для сбора телеметрии (трейсы, метрики, логи) во всех сервисах.

### Последствия
**Положительные:**
- Единый стандарт для всей телеметрии
- Поддержка множества бэкендов (Jaeger, Zipkin, Prometheus)
- Автоматическая инструментация для многих библиотек
- Активно развивающееся сообщество и стандарт

**Отрицательные:**
- Относительная новизна стандарта (некоторая нестабильность API)
- Необходимость инструментации всех сервисов
- Дополнительные накладные расходы на сбор и хранение данных

### Рассмотренные альтернативы
1. **Jaeger/Zipkin напрямую:** Отклонен из-за отсутствия единого стандарта и поддержки метрик.
2. **Проприетарные решения (Datadog, New Relic):** Рассмотрены, но отклонены из-за высокой стоимости и vendor lock-in.
3. **Собственное решение:** Отклонен из-за высоких затрат на разработку и поддержку.

### Связанные решения
- ADR-012 (Стратегия мониторинга)

---

## ADR-010: GraphQL для внешнего API

### Статус
Принято (2024-01-19)

### Контекст
Клиентские приложения (iOS, Android, Web) имеют разные требования к данным. Мобильным клиентам особенно важно минимизировать объем передаваемых данных и количество запросов.

### Решение
Использовать GraphQL в качестве основного протокола для внешнего API (клиент-серверное взаимодействие).

### Последствия
**Положительные:**
- Клиенты запрашивают только нужные данные (минимизация передачи)
- Единая конечная точка для всех запросов
- Строгая типизация API
- Возможность агрегации данных из нескольких сервисов на уровне API Gateway
- Автоматическая документация через introspection

**Отрицательные:**
- Сложность кэширования (по сравнению с REST)
- Потенциальные проблемы с производительностью при сложных запросах (N+1)
- Сложность валидации и авторизации на уровне полей
- Дополнительная нагрузка на сервер для парсинга и валидации запросов

### Рассмотренные альтернативы
1. **REST:** Отклонен из-за over-fetching и under-fetching данных, а также необходимости поддерживать множество endpoint'ов.
2. **gRPC:** Рассмотрен для мобильных клиентов, но отклонен из-за сложности работы в браузерах и менее гибкого формата запросов.
3. **REST + спецификация (OpenAPI):** Рассмотрен, но отклонен в пользу более гибкого GraphQL.

### Связанные решения
- ADR-004 (Protocol Buffers для внутренней коммуникации)

---

## ADR-011: Применение Domain-Driven Design (DDD) для моделирования бизнес-логики

### Статус
Принято (2024-01-20)

### Контекст
Требуется смоделировать сложную бизнес-логику фитнес-социального приложения с четким разделением ответственности. Приложение включает:
- Социальные взаимодействия (друзья, группы, сообщества)
- Тренировочные процессы и метрики
- Интеграцию медицинских устройств
- Систему рекомендаций и коммерции

### Решение
Применить подход Domain-Driven Design (DDD) с выделением ограниченных контекстов:
1. **Core Domain:** User & Social Context (смысловое ядро)
2. **Supporting Domains:** Activity & Training, Health & Devices, Commerce & Recommendations
3. **Generic Domains:** Геймификация, Уведомления, Аналитика

### Последствия
**Положительные:**
- Архитектура точно отражает бизнес-процессы
- Единый язык между разработчиками и бизнесом
- Четкие границы ответственности для каждой команды
- Возможность независимой эволюции доменов
- Упрощение тестирования бизнес-логики

**Отрицательные:**
- Кривая обучения для команды
- Начальные затраты на проектирование доменной модели
- Сложность координации между контекстами
- Необходимость поддержания целостности агрегатов

### Рассмотренные альтернативы
1. **Традиционный слоистый подход (N-слойная архитектура):** Отклонен из-за недостаточной гибкости и проблем с масштабированием команд.
2. **Только микросервисы без DDD:** Отклонен из-за риска создания distributed monolith.
3. **Event Storming с последующим DDD:** Рассмотрен и принят как часть процесса проектирования.

### Связанные решения
- ADR-001 (Микросервисная архитектура)
- ADR-012 (Стратегия выделения ограниченных контекстов)
- ADR-013 (Моделирование агрегатов и инвариантов)

---

## ADR-012: Выделение Core Domain и стратегия ограниченных контекстов

### Статус
Принято (2024-01-21)

### Контекст
В рамках DDD подхода необходимо определить Core Domain (смысловое ядро) и стратегию разделения системы на ограниченные контексты.

### Решение
Определить Core Domain как **User & Social Context**, так как социальная вовлеченность и формирование комьюнити является основной бизнес-ценностью приложения.

Стратегия ограниченных контекстов:
1. **User & Social Context (Core):** Управление пользователями, социальным графом, группами
2. **Activity & Training Context (Supporting):** Тренировки, упражнения, метрики
3. **Health & Device Context (Supporting):** Медицинские данные, интеграция устройств
4. **Commerce & Recommendations Context (Supporting):** Продажи, рекомендации, промоакции

### Последствия
**Положительные:**
- Фокус ресурсов на наиболее важной части системы
- Четкое разделение зон ответственности команд
- Упрощение коммуникации через единый язык в каждом контексте
- Возможность разного темпа развития для разных контекстов

**Отрицательные:**
- Риск неправильного выделения границ контекстов
- Необходимость координации между командами Core и Supporting доменов
- Сложность управления зависимостями между контекстами
- Потенциальная избыточность данных между контекстами

### Рассмотренные альтернативы
1. **Activity как Core Domain:** Отклонен, так как социальная компонента является дифференцирующим фактором.
2. **Не выделять Core Domain:** Отклонен, так как это приводит к распылению ресурсов.
3. **Более детальное разделение (7+ контекстов):** Отклонен из-за чрезмерной сложности для MVP.

### Связанные решения
- ADR-011 (Применение DDD)
- ADR-013 (Моделирование агрегатов)

---

## ADR-013: Моделирование агрегатов и бизнес-валидация

### Статус
Принято (2024-01-22)

### Контекст
Для каждого ограниченного контекста необходимо определить агрегаты с инкапсулированной бизнес-логикой и валидацией.

### Решение
Смоделировать ключевые агрегаты с четкими инвариантами:

**User & Social Context:**
- `User` (агрегат-корень): инвариант - максимум 5000 друзей
- `SocialGroup`: инвариант - минимальный возраст участников 16 лет

**Activity & Training Context:**
- `TrainingSession`: бизнес-правила валидации ЧСС, GPS, калорий
- `TrainingPlan`: инвариант - непротиворечивость расписания

**Health & Device Context:**
- `HealthMetric`: валидация по медицинским стандартам
- `Device`: калибровка и проверка точности данных

**Commerce & Recommendations Context:**
- `Product`: проверка совместимости с тренировочными планами
- `Recommendation`: правила персонализации (70% история, 30% социальный граф)

### Последствия
**Положительные:**
- Инкапсуляция сложности бизнес-правил
- Гарантия целостности данных на уровне агрегатов
- Упрощение тестирования бизнес-логики
- Четкое разделение ответственности

**Отрицательные:**
- Сложность проектирования границ агрегатов
- Риск создания слишком крупных агрегатов
- Необходимость тщательного проектирования транзакций
- Потенциальные проблемы с производительностью

### Рассмотренные альтернативы
1. **Анемичная модель:** Отклонена из-за рассеивания бизнес-логики по сервисам.
2. **Крупные агрегаты:** Отклонены из-за проблем с конкурентным доступом.
3. **Event Sourcing для всех агрегатов:** Отклонен как избыточный для MVP.

### Связанные решения
- ADR-011 (Применение DDD)
- ADR-014 (Стратегия обработки доменных событий)

---

## ADR-014: Стратегия интеграции между ограниченными контекстами

### Статус
Принято (2024-01-23)

### Контекст
Ограниченные контексты должны взаимодействовать друг с другом, сохраняя при этом свою автономию.

### Решение
Применить комбинированную стратегию интеграции:

1. **Асинхронная коммуникация через события:**
   - Доменные события через Apache Kafka
   - Eventual consistency между контекстами

2. **REST API для синхронных операций:**
   - Для операций, требующих немедленного ответа
   - С применением Circuit Breaker

3. **Типы связей между контекстами:**
   - Partnership между User & Social и Activity & Training
   - Customer-Supplier между Activity и Health & Devices
   - Conformist для интеграции с внешними системами

### Последствия
**Положительные:**
- Сохранение автономии контекстов
- Улучшенная отказоустойчивость
- Возможность независимого масштабирования
- Поддержка разных циклов разработки

**Отрицательные:**
- Сложность поддержания согласованности данных
- Необходимость обработки дублирующихся событий
- Сложность отладки распределенных транзакций
- Дополнительные накладные расходы на сериализацию

### Рассмотренные альтернативы
1. **Синхронная RPC для всей системы:** Отклонена из-за сильного связывания.
2. **Shared Database:** Отклонена как нарушающая принципы DDD.
3. **Дублирование данных без четкой стратегии:** Отклонена как опасная и приводящая к неконсистентности.

### Связанные решения
- ADR-002 (Apache Kafka)
- ADR-004 (Protocol Buffers)
- ADR-008 (Circuit Breaker)

---

## Матрица статусов ADR

| ADR | Статус | Дата принятия | Ответственный |
|-----|--------|---------------|----------------|
| ADR-001 | Принято | 2024-01-15 | Ведущий архитектор |
| ADR-002 | Принято | 2024-01-15 | Архитектор бэкенда |
| ADR-003 | Принято | 2024-01-16 | Архитектор данных |
| ADR-004 | Принято | 2024-01-16 | Архитектор бэкенда |
| ADR-005 | Принято | 2024-01-17 | Архитектор инфраструктуры |
| ADR-006 | Принято | 2024-01-17 | DevOps Lead |
| ADR-007 | Принято | 2024-01-18 | Ведущий архитектор |
| ADR-008 | Принято | 2024-01-18 | Архитектор бэкенда |
| ADR-009 | Принято | 2024-01-19 | DevOps Lead |
| ADR-010 | Принято | 2024-01-19 | Архитектор фронтенда |
| ADR-011 | Принято | 2024-01-20 | Ведущий архитектор |
| ADR-012 | Принято | 2024-01-21 | DDD Lead |
| ADR-013 | Принято | 2024-01-22 | Архитектор бэкенда |
| ADR-014 | Принято | 2024-01-23 | Архитектор интеграций |

---

## Процесс управления ADR

1. **Создание:** Любой член команды может предложить ADR, создав черновик в репозитории.
2. **Обсуждение:** ADR обсуждается на архитектурном комитете или в pull request.
3. **Принятие:** Решение принимается консенсусом или, при необходимости, голосованием.
4. **Реализация:** Принятые ADR реализуются в соответствующем порядке приоритетов.
5. **Обзор:** ADR периодически пересматриваются на актуальность (каждые 6 месяцев).
6. **Архивация:** Устаревшие ADR помечаются как deprecated с указанием заменяющего решения.

