# Представление многозадачности (Concurrency View)

## Обзор параллелизма в DDD-ориентированной системе

### Контекст и требования

Фитнес-социальное приложение построено на принципах Domain-Driven Design и должно поддерживать глобальную аудиторию с разнообразными сценариями использования.

**Ключевые требования к параллелизму в DDD-контексте:**

- **Конкурентное обновление агрегатов:** Одновременные изменения одних и тех же агрегатов разными пользователями.
- **Геораспределённость:** Обработка событий в разных регионах с минимальной задержкой.
- **Согласованность между ограниченными контекстами:** Eventual consistency через доменные события.
- **Массовые события:** Обработка тысяч одновременных участников в соревнованиях и челленджах.
- **Потоковая обработка телеметрии:** Данные с фитнес-устройств в реальном времени.

---

## 1. DDD и конкурентность: Основные принципы

### 1.1 Управление состоянием агрегатов

**Агрегаты как границы консистентности:**

- Каждый агрегат обрабатывается в рамках одной транзакции.
- Агрегат-корень гарантирует инварианты всей совокупности сущностей.
- Внешние ссылки только на идентификаторы агрегатов-корней.

**Версионирование агрегатов для конкурентного контроля:**

- Оптимистичные блокировки через поле `version` в каждом агрегате.
- При каждом изменении агрегата версия увеличивается.
- Если версия при обновлении не совпадает с ожидаемой, возникает конфликт параллелизма.

### 1.2 Доменные события и eventual consistency

**Механизм согласованности между контекстами:**

- Асинхронная публикация доменных событий при изменении агрегатов.
- Потребители событий обновляют свои проекции данных.
- Гарантии доставки: At-least-once семантика.

**Пример цепочки событий для социального взаимодействия:**

1. Пользователь завершает тренировку → `TrainingSession` публикует `WorkoutCompleted`.
2. `SocialGraphService` получает событие → обновляет ленту активности.
3. `GamificationEngine` получает событие → начисляет баллы.
4. `RecommendationService` получает событие → обновляет модели.

### 1.3 Изоляция транзакций по ограниченным контекстам

**Каждый ограниченный контекст имеет свою стратегию управления транзакциями:**

- **User & Social Context:** Короткие транзакции с оптимистичными блокировками.
- **Activity & Training Context:** Длинные транзакции (сессии тренировок) с компенсирующими операциями.
- **Health & Device Context:** Транзакции с гарантией доставки и подтверждением.
- **Commerce & Recommendations Context:** Саги для распределённых транзакций.

---

## 2. Массовая обработка и управление пиковыми нагрузками

### 2.1 Архитектура Producer-Consumer для массовых событий

**Проблема:** Обработка тысяч одновременных регистраций на глобальные спортивные события.

**Решение: Producer-Consumer паттерн с Apache Kafka**

**Компоненты массовой обработки:**

1. **API Gateway:**
   - Принимает входящие запросы регистрации
   - Валидирует и форматирует данные
   - Помещает сообщения в очередь Kafka с гарантированной доставкой

2. **Apache Kafka Cluster:**
   - Топик: `event-registrations-{eventId}`
   - Партиционирование по географическим регионам
   - Replication factor: 3 для отказоустойчивости
   - Retention policy: 7 дней

3. **Worker Pool (Consumer Groups):**
   - Автомасштабируемая группа воркеров (5-100 инстансов)
   - Каждый воркер обрабатывает сообщения из назначенных партиций
   - Базовая настройка: 10 воркеров, масштабирование до 100 при нагрузке

4. **Batch Processing Service:**
   - Обрабатывает сообщения батчами по 1000 записей
   - Применяет компенсирующие транзакции для отката при ошибках
   - Обновляет статусы обработки в реальном времени

### 2.2 Стратегии батчевой обработки

**Конфигурация батчей:**

- **Размер батча:** 1000 сообщений или 30 секунд накопления
- **Максимальный размер батча:** 5000 сообщений
- **Таймаут обработки батча:** 60 секунд
- **Параллельная обработка:** До 10 батчей одновременно

**Гарантии обработки:**

- **Exactly-once семантика:** Через идемпотентность и транзакционность
- **Порядок обработки:** Сохранение порядка в рамках партиции
- **Мониторинг прогресса:** Отслеживание процента обработанных сообщений

**Обработка ошибок:**

- **Dead Letter Queue:** Для сообщений с неустранимыми ошибками
- **Экспоненциальная отсрочка:** Повторная обработка с задержкой
- **Ручное вмешательство:** Возможность повторной обработки DLQ

### 2.3 Пессимистические блокировки для ограниченных ресурсов

**Проблема:** Конфликты при бронировании ограниченного количества мест на события.

**Решение: Redis-based Distributed Locking:**

**Алгоритм Redlock:**

1. **Получение блокировки:**
   - Генерация уникального идентификатора блокировки
   - Попытка установки блокировки в N инстансах Redis
   - Блокировка считается полученной при успехе в большинстве инстансов

2. **Параметры блокировки:**
   - **Время жизни:** 30 секунд (автоматическое освобождение)
   - **Обновление:** Возможность продления действующей блокировки
   - **Таймаут получения:** 5 секунд на попытку получения

3. **Освобождение блокировки:**
   - Проверка владельца перед освобождением
   - Атомарное удаление блокировки
   - Автоматическое освобождение при истечении TTL

**Использование в бизнес-логике бронирования места на событии:**

1. Получить блокировку для события (event:{eventId}:lock)
2. Проверить доступность мест
3. Зарезервировать место для пользователя
4. Освободить блокировку

**Обработка исключительных ситуаций:**

- **Таймаут блокировки:** Автоматический откат операции
- **Смерть процесса:** Автоматическое освобождение по TTL
- **Сетевые сбои:** Повторные попытки с экспоненциальной отсрочкой

### 2.4 Auto-scaling для массовой обработки

**Метрики для автомасштабирования:**

- **Длина очереди Kafka:** Более 10,000 сообщений → масштабирование
- **Задержка обработки:** P95 > 5 секунд → масштабирование
- **Утилизация CPU:** >70% в течение 5 минут → масштабирование
- **Количество ошибок:** >5% отказов → расследование

**Политики масштабирования:**

- **Реактивное масштабирование:** На основе текущих метрик
- **Предиктивное масштабирование:** Перед запланированными событиями
- **По расписанию:** Увеличение мощности в часы пик


## 3. Обработка потоковых данных с фитнес-устройств

### 3.1 Архитектура потоковой обработки

**Поток данных:** Источники событий → Обработчики потоков → Стоки данных.

**Источники событий:**

- Датчики фитнес-устройств: Пульс (1-100 Гц), GPS (1 Гц), акселерометр (50 Гц), шагомер.
- Действия пользователей: Старт/стоп тренировки, изменение целей, просмотр контента.
- Социальные взаимодействия: Лайки, комментарии, подписки, сообщения, челленджи.
- Системные события: Уведомления, напоминания, обновления статуса, системные метрики.
- Внешние данные: Погодные условия, картографическая информация, спортивные события.

### 3.2 Типы обработчиков потоков:

1. **Real-time агрегаторы:**
   - Мгновенный расчет статистики тренировок (текущий темп, сожженные калории).
   - Мониторинг физиологических показателей в реальном времени.
   - Определение достижений и рекордов по мере поступления данных.

2. **Оконные процессоры:**
   - **Фиксированные окна:** Статистика за 1 секунду, 1 минуту, 5 минут, 1 час.
   - **Скользящие окна:** Средние значения за последние N измерений.
   - **Сессионные окна:** Обработка данных в рамках одной тренировочной сессии.
   - **Tumbling windows:** Агрегация по календарным интервалам (день, неделя, месяц).

3. **Корреляционные движки:**
   - Выявление взаимосвязей между разными типами событий.
   - Обнаружение паттернов поведения (регулярность тренировок, прогресс).
   - Определение социального влияния (как активность друзей влияет на мотивацию).

4. **Обогатители данных:**
   - Добавление контекстной информации из профилей пользователей.
   - Обогащение геоданных информацией о местности и погоде.
   - Привязка событий к спортивному инвентарю и оборудованию.

---

## 4. Управление состоянием и синхронизация в DDD

### 4.1 Модели консистентности данных

**Стратегии для разных типов данных:**

- **Строгая консистентность:** Пользовательские профили, финансовые транзакции.
- **Eventual consistency:** Социальные взаимодействия, лайки, комментарии.
- **Session consistency:** Данные активной тренировки, временные метрики.
- **Causal consistency:** Цепочки сообщений, поток активности.

### 4.2 Механизмы синхронизации

**Оптимистичные блокировки:**

- **Применение:** Обновление статистики, рейтингов, достижений.
- **Механизм:** Версионирование записей, проверка перед записью.
- **Разрешение конфликтов:** Last write wins с меткой времени, слияние изменений.

**Распределённые транзакции:**

- **Паттерн Saga:** Для бизнес-транзакций, затрагивающих несколько сервисов.
- **Компенсирующие операции:** Откат через обратные действия.
- **Идемпотентность:** Гарантия безопасного повторного выполнения.

**Шардированные агрегаты:**

- **Геошардирование:** Данные пользователей по регионам.
- **Временное шардирование:** Данные тренировок по временным диапазонам.
- **Хэш-шардирование:** Равномерное распределение нагрузки.

### 4.3 Стратегии для массовых событий

**Подготовка к массовым соревнованиям:**

1. **Предварительное масштабирование:** Увеличение мощности за 24 часа до события.
2. **Шардирование данных:** Распределение участников по разным шардам.
3. **Локальные кэши:** Кэширование общих данных на edge-локациях.
4. **Упрощённая логика:** Включение degraded mode для сложных вычислений.

**Обработка пиковых нагрузок:**

- **Динамическое масштабирование:** Автоматическое добавление ресурсов.
- **Rate limiting:** Ограничение запросов для защиты от перегрузки.
- **Приоритетная обработка:** Критичные операции обрабатываются в первую очередь.
- **Асинхронная обработка:** Отложенная обработка некритичных задач.

---

## 5. Очереди сообщений и планирование задач

### 5.1 Многоуровневая система очередей

**Приоритетные очереди:**

- **Высокий приоритет:** Уведомления в реальном времени, экстренные оповещения.
- **Средний приоритет:** Социальные взаимодействия, обновления ленты.
- **Низкий приоритет:** Аналитические задачи, email-рассылки, бэкапы.

**Стратегии обработки:**

- **Round Robin:** Равномерное распределение между воркерами.
- **Least Connections:** Направление в наименее загруженный обработчик.
- **Sticky Sessions:** Привязка пользовательских событий к конкретному воркеру.

**Мониторинг очередей:**

- **Длина очереди:** Количество ожидающих обработки сообщений.
- **Время ожидания:** Среднее время нахождения сообщения в очереди.
- **Процент отказов:** Сообщения, которые не удалось обработать.
- **Скорость обработки:** Количество обработанных сообщений в единицу времени.

### 5.2 Распределённые планировщики

**Типы запланированных задач:**

- **Периодические:** Ежечасное обновление лидербордов, ежедневная статистика.
- **Отложенные:** Напоминания о тренировках, отложенные уведомления.
- **Зависимые:** Цепочки задач с условиями выполнения.

**Гарантии выполнения:**

- **At least once:** Критичные бизнес-процессы.
- **At most once:** Статистические вычисления, аналитика.
- **Exactly once:** Финансовые операции, начисления баллов.

---

## 6. Масштабирование и балансировка нагрузки

### 6.1 Стратегии горизонтального масштабирования

**Метрики для автомасштабирования:**

- **CPU/Memory utilization:** Порог 70% для масштабирования вверх.
- **Request rate:** Количество запросов в секунду на инстанс.
- **Queue length:** Длина очереди сообщений для обработчиков событий.
- **P95 latency:** 95-й процентиль времени ответа.

**Политики масштабирования:**

- **Predictive scaling:** Предсказание нагрузки на основе расписания событий.
- **Reactive scaling:** Реакция на текущие метрики нагрузки.
- **Scheduled scaling:** Плановое увеличение мощности для известных событий.

### 6.2 Глобальная балансировка нагрузки

**Geo-based routing:**

- **DNS-based:** Перенаправление на ближайший регион.
- **Anycast:** Распределение на уровне сети.
- **Application-level:** Определение региона по заголовкам запроса.

**Стратегии балансировки внутри региона:**

- **Least Connections:** Для долгоживущих соединений WebSocket.
- **Round Robin:** Для stateless HTTP запросов.
- **IP Hash:** Для привязки сессий пользователей.

---

## 7. Защита от перегрузок

### 7.1 Rate Limiting политики

**Per user limits:**

- 100 запросов/минуту для API endpoints.
- 50 запросов/минуту для социальных взаимодействий.
- 10 запросов/минуту для операций с финансовыми данными.

**Per IP limits:**

- 1000 запросов/минуту для защиты от ботов.
- 500 запросов/минуту для неаутентифицированных запросов.
- 200 запросов/минуту для сканирования данных.

**Burst allowance:**

- Кратковременное превышение лимитов для легитимных пользователей.
- Плавное восстановление после всплеска активности.
- Динамическая корректировка лимитов на основе поведения.

### 7.2 Circuit Breaker паттерны

**Три состояния:**

- **Closed:** Нормальная работа, все запросы проходят.
- **Open:** Сервис недоступен, запросы не проходят.
- **Half-Open:** Ограниченное количество запросов для проверки восстановления.

**Метрики срабатывания:**

- **Процент ошибок:** При превышении 50% в течение 30 секунд.
- **Время ответа:** При превышении 5 секунд для 95% запросов.
- **Количество таймаутов:** Более 10 таймаутов в минуту.

**Восстановление:**

- Постепенное возобновление трафика после восстановления сервиса.
- Экспоненциальная отсрочка между попытками.
- Мониторинг стабильности после возврата в нормальное состояние.

### 7.3 Bulkhead изоляция

**Разделение ресурсов:**

- **Пул потоков:** Отдельные пулы для разных типов операций.
- **Connection pools:** Раздельные соединения для критичных и некритичных сервисов.
- **Очереди сообщений:** Изоляция трафика разных функциональных областей.

**Преимущества изоляции:**

- **Локализация сбоев:** Проблемы в одном компоненте не влияют на другие.
- **Predictable performance:** Гарантированные ресурсы для критичных операций.
- **Graceful degradation:** Постепенное ухудшение функциональности при перегрузках.

---

## 8. Мониторинг и observability

### 8.1 Distributed tracing

**Трассировка запросов:**

- **End-to-end tracing:** Отслеживание запросов через все сервисы.
- **Dependency mapping:** Автоматическое построение карты зависимостей.
- **Latency analysis:** Выявление узких мест в цепочке обработки.
- **Error correlation:** Связь ошибок с конкретными запросами и пользователями.

**Инструменты:**

- **OpenTelemetry:** Стандарт для сбора телеметрии.
- **Jaeger:** Хранение и визуализация трейсов.
- **Prometheus:** Сбор метрик производительности.
- **Grafana:** Визуализация метрик и создание дашбордов.

### 8.2 Алертинг и реагирование

**Уровни алертов:**

- **Critical:** Немедленное реагирование, остановка бизнес-процессов.
- **Warning:** Требует внимания, но не останавливает работу.
- **Info:** Информационные сообщения для анализа.

**Процесс реагирования:**

1. **Обнаружение:** Система мониторинга обнаруживает аномалию.
2. **Эскалация:** Уведомление ответственной команды.
3. **Диагностика:** Анализ причин проблемы.
4. **Восстановление:** Применение исправлений.
5. **Постмортем:** Анализ инцидента и предотвращение повторения.

---

## 9. Стратегии устойчивости к ошибкам

### 9.1 Экспоненциальная отсрочка

**Параметры повторных попыток:**

- **Базовая задержка:** 100 мс с экспоненциальным увеличением до 10 секунд.
- **Максимальное количество попыток:** 5 для пользовательских операций, 10 для системных.
- **Jitter:** Случайная добавка для предотвращения синхронизации повторных попыток.

**Условия повторения:**

- **Transient errors:** Таймауты, временная недоступность, сетевые сбои.
- **Non-retryable errors:** Ошибки валидации, недостаток прав, логические ошибки.
- **Circuit breaker integration:** Прекращение повторных попыток при открытом circuit breaker.

### 9.2 Graceful degradation

**Стратегии деградации:**

- **Отключение не критичных функций:** Сложные рекомендации, детальная аналитика.
- **Упрощение расчетов:** Аппроксимация статистики, кэширование лидербордов.
- **Fallback стратегии:** Возврат закэшированных данных при недоступности сервиса.
- **Ограничение функциональности:** Временное отключение социальных функций для сохранения основных.

**Приоритеты при деградации:**

1. **Безопасность и конфиденциальность:** Не должны быть нарушены.
2. **Основные функции:** Тренировки и сбор данных.
3. **Социальные функции:** Лента активности, группы, друзья.
4. **Расширенные возможности:** Рекомендации, аналитика, геймификация.

---

## Заключение

Архитектура параллелизма фитнес-социального приложения построена на принципах Domain-Driven Design и обеспечивает:

1. **Конкурентную обработку агрегатов** через оптимистичные блокировки и версионирование.
2. **Eventual consistency между ограниченными контекстами** через доменные события.
3. **Масштабируемость до миллионов пользователей** через горизонтальное шардирование.
4. **Устойчивость к пиковым нагрузкам** через circuit breakers, rate limiting и graceful degradation.
5. **Наблюдаемость и мониторинг** через distributed tracing и комплексные метрики.

Данная архитектура позволяет системе эффективно обрабатывать массовые события, поддерживать глобальную аудиторию и обеспечивать высокую доступность при любых нагрузках.



